name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  DOCKER_IMAGE: artie92/asset-manager
  DOCKER_TAG: latest

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest

      - name: Run tests
        run: |
          cd website
          python -m pytest || echo "No tests found, continuing..."

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: env.DOCKER_USERNAME != '' && env.DOCKER_PASSWORD != ''
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=inline

  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      - name: Upload terraform state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: terraform/terraform.tfstate

      - name: Generate Ansible inventory
        working-directory: ./terraform
        run: |
          MASTER_IP=$(terraform output -raw master_public_ip)
          WORKER1_IP=$(terraform output -raw worker1_public_ip)
          WORKER2_IP=$(terraform output -raw worker2_public_ip)
          
          cat > ../ansible/inventory.ini <<EOF
          [master]
          $MASTER_IP ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/cluster-key.pem

          [workers]
          $WORKER1_IP ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/cluster-key.pem
          $WORKER2_IP ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/cluster-key.pem

          [all:vars]
          ansible_python_interpreter=/usr/bin/python3
          EOF
          
          echo "Generated inventory:"
          cat ../ansible/inventory.ini

      - name: Upload inventory
        uses: actions/upload-artifact@v4
        with:
          name: ansible-inventory
          path: ansible/inventory.ini

  ansible:
    name: Configure Kubernetes Cluster
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download inventory
        uses: actions/download-artifact@v4
        with:
          name: ansible-inventory
          path: ansible/

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          # Write key, removing any trailing newlines/whitespace
          echo "${{ secrets.SSH_PRIVATE_KEY }}" | sed 's/[[:space:]]*$//' > ~/.ssh/cluster-key.pem
          chmod 600 ~/.ssh/cluster-key.pem
          # Verify key format
          echo "Verifying SSH key format..."
          if head -1 ~/.ssh/cluster-key.pem | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "✅ Key format looks correct"
          else
            echo "⚠️ Key format may be incorrect - first line:"
            head -1 ~/.ssh/cluster-key.pem
          fi
          echo "Key file size: $(wc -c < ~/.ssh/cluster-key.pem) bytes"
          echo "Last line check:"
          tail -1 ~/.ssh/cluster-key.pem | grep -q "END.*PRIVATE KEY" && echo "✅ End marker found" || echo "⚠️ End marker missing"
          # Try to validate key with ssh-keygen (if available)
          if command -v ssh-keygen >/dev/null 2>&1; then
            ssh-keygen -y -f ~/.ssh/cluster-key.pem >/dev/null 2>&1 && echo "✅ Key validation passed" || echo "⚠️ Key validation failed"
          fi

      - name: Install Ansible core 2.14.x
        run: |
          pip3 install 'ansible-core==2.14.17'
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup AWS CLI for instance status checks
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Wait for SSH readiness
        working-directory: ./ansible
        run: |
          echo "Waiting for EC2 instances to be SSH-ready..."
          
          # Parse IPs from inventory
          MASTER_IP=$(grep -A1 "^\[master\]" inventory.ini | tail -1 | awk '{print $1}')
          WORKER1_IP=$(grep -A1 "^\[workers\]" inventory.ini | tail -1 | awk '{print $1}')
          WORKER2_IP=$(grep -A2 "^\[workers\]" inventory.ini | tail -1 | awk '{print $1}')
          
          echo "Master: $MASTER_IP"
          echo "Worker1: $WORKER1_IP"
          echo "Worker2: $WORKER2_IP"
          
          for ip in $MASTER_IP $WORKER1_IP $WORKER2_IP; do
            echo "Waiting for SSH on $ip..."
            # Increased to 60 attempts (10 minutes) - instances may take longer to boot
            for i in {1..60}; do
              # Try SSH with explicit key types for older systems
              if ssh -o ConnectTimeout=5 \
                   -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o PubkeyAcceptedKeyTypes=+ssh-rsa \
                   -o HostkeyAlgorithms=+ssh-rsa \
                   -i ~/.ssh/cluster-key.pem ec2-user@$ip "echo ready" 2>/dev/null; then
                echo "✅ SSH ready for $ip after $((i * 10)) seconds"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "❌ SSH timeout for $ip after 60 attempts (10 minutes)"
                echo ""
                echo "=== DIAGNOSTIC INFORMATION ==="
                echo ""
                echo "1. Checking instance status and key pair name..."
                INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=ip-address,Values=$ip" \
                  --query 'Reservations[*].Instances[*].[InstanceId,State.Name,KeyName,PublicIpAddress]' \
                  --output text | head -1)
                echo "Instance details: $INSTANCE_ID"
                aws ec2 describe-instances --filters "Name=ip-address,Values=$ip" \
                  --query 'Reservations[*].Instances[*].[InstanceId,State.Name,KeyName,PublicIpAddress,PrivateIpAddress]' \
                  --output table || echo "Could not query instance status"
                echo ""
                echo "⚠️ IMPORTANT: Verify that the key pair name above matches 'vockey'"
                echo "   and that SSH_PRIVATE_KEY secret contains the correct vockey.pem content"
                echo ""
                echo "2. Testing SSH connection (showing actual error)..."
                ssh -v -o ConnectTimeout=5 -o StrictHostKeyChecking=no \
                    -i ~/.ssh/cluster-key.pem ec2-user@$ip "echo test" 2>&1 | head -30 || true
                echo ""
                echo "3. Checking if key file exists and permissions..."
                ls -la ~/.ssh/cluster-key.pem || echo "Key file not found"
                echo ""
                echo "4. First line of key file (should start with '-----BEGIN'):"
                head -1 ~/.ssh/cluster-key.pem || echo "Could not read key file"
                echo ""
                exit 1
              fi
              if [ $((i % 6)) -eq 0 ]; then
                echo "Attempt $i/60 - still waiting... ($((i * 10)) seconds elapsed)"
                # Check instance status every 60 seconds
                echo "Checking instance status..."
                aws ec2 describe-instances --filters "Name=ip-address,Values=$ip" \
                  --query 'Reservations[*].Instances[*].[State.Name,PublicIpAddress]' \
                  --output text 2>/dev/null || echo "Could not check status"
              fi
              sleep 10
            done
          done
          echo "All instances SSH-ready!"

      - name: Run Ansible playbooks
        working-directory: ./ansible
        run: |
          echo "Running playbook 1: Common setup..."
          ansible-playbook -i inventory.ini playbooks/01-common-setup.yml
          
          echo "Running playbook 2: Master setup..."
          ansible-playbook -i inventory.ini playbooks/02-master-setup.yml
          
          echo "Waiting 30 seconds for Kubernetes API..."
          sleep 30
          
          echo "Running playbook 3: Worker setup..."
          ansible-playbook -i inventory.ini playbooks/03-worker-setup.yml
          
          echo "Running playbook 4: NFS setup..."
          ansible-playbook -i inventory.ini playbooks/04-nfs-setup.yml
          
          echo "All playbooks completed!"

  helm:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: ansible
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download terraform state
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: terraform/

      - name: Setup Terraform for outputs
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform init for outputs
        working-directory: ./terraform
        run: terraform init -input=false

      - name: Get master IP
        id: get-master
        working-directory: ./terraform
        run: |
          echo "master_ip=$(terraform output -raw master_public_ip)" >> $GITHUB_OUTPUT

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.12.0"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/cluster-key.pem
          chmod 600 ~/.ssh/cluster-key.pem

      - name: Wait for kubeconfig and API
        run: |
          MASTER_IP="${{ steps.get-master.outputs.master_ip }}"
          mkdir -p ~/.kube
          
          echo "Waiting for Kubernetes admin.conf on master..."
          for i in {1..60}; do
            if ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                 ec2-user@$MASTER_IP "test -f /etc/kubernetes/admin.conf" 2>/dev/null; then
              echo "admin.conf found!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "Timeout waiting for admin.conf"
              exit 1
            fi
            echo "Attempt $i/60..."
            sleep 10
          done
          
          echo "Copying kubeconfig..."
          KUBECONFIG_PATH="$HOME/.kube/config"
          for i in {1..30}; do
            # Use absolute path on remote side
            if scp -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                 ec2-user@$MASTER_IP:/home/ec2-user/.kube/config "$KUBECONFIG_PATH" 2>/dev/null; then
              echo "kubeconfig copied!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Timeout copying kubeconfig"
              echo "Trying to debug..."
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "ls -la /home/ec2-user/.kube/config" || echo "File not found on master"
              exit 1
            fi
            sleep 10
          done
          
          echo "Waiting for Kubernetes API..."
          echo "Testing API via SSH on master node (API server not accessible from outside)..."
          
          # Try for 10 minutes max (60 attempts × 10 seconds)
          # Run kubectl on master via SSH since API server is only accessible from VPC
          for i in {1..60}; do
            if ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                 ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config cluster-info 2>/dev/null" >/dev/null 2>&1; then
              echo "✅ K8s API ready after $((i * 10)) seconds"
              # Show cluster info
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config cluster-info" | head -3
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ FAILED: K8s API not ready after 10 minutes"
              echo ""
              echo "=== DIAGNOSTIC INFORMATION ==="
              echo ""
              echo "1. Testing kubectl on master..."
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config cluster-info 2>&1" || true
              echo ""
              echo "2. Checking kubelet status on master..."
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "sudo systemctl status kubelet --no-pager | head -20" || true
              echo ""
              echo "3. Checking if API server pod is running..."
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "sudo crictl ps | grep kube-apiserver || echo 'No API server pod found'" || true
              echo ""
              echo "4. All control plane pods:"
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "sudo crictl ps | head -10" || true
              echo ""
              echo "5. Recent kubelet errors:"
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "sudo journalctl -u kubelet --since '10 minutes ago' -n 20 | grep -i 'error\|fail' || echo 'No recent errors'" || true
              echo ""
              exit 1
            fi
            if [ $((i % 6)) -eq 0 ]; then
              echo "Attempt $i/60: Still waiting... ($((i * 10)) seconds elapsed)"
              # Test kubectl on master
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                  ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config cluster-info 2>&1 | head -2" || echo "API not ready yet"
            fi
            sleep 10
          done

      - name: Wait for nodes Ready
        run: |
          MASTER_IP="${{ steps.get-master.outputs.master_ip }}"
          echo "Waiting for all 3 nodes to be Ready..."
          echo "Checking nodes via SSH on master (API server not accessible from outside)..."
          for i in {1..30}; do
            READY=$(ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
              ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config get nodes --no-headers 2>/dev/null | grep -c ' Ready' || echo 0")
            echo "Ready nodes: $READY/3"
            if [ "$READY" -ge 3 ]; then
              echo "All nodes Ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Timeout waiting for nodes"
              ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
                ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config get nodes"
              exit 1
            fi
            sleep 10
          done
          echo "Node status:"
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config get nodes"

      - name: Deploy with Helm
        run: |
          MASTER_IP="${{ steps.get-master.outputs.master_ip }}"
          echo "Installing Helm on master node..."
          # Install Helm on master if not already installed
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "command -v helm >/dev/null 2>&1 || { \
              curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash; \
            }"
          
          echo "Copying Helm charts to master node..."
          # Create temp directory and copy charts
          tar -czf /tmp/helm-charts.tar.gz -C helm/asset-manager .
          scp -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            /tmp/helm-charts.tar.gz ec2-user@$MASTER_IP:/tmp/
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "mkdir -p /tmp/helm-deploy && cd /tmp/helm-deploy && tar -xzf /tmp/helm-charts.tar.gz"
          
          echo "Deploying application with Helm on master..."
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "cd /tmp/helm-deploy && \
            export KUBECONFIG=/home/ec2-user/.kube/config && \
            helm upgrade --install asset-manager . \
              --set nfs.server=10.0.1.10 \
              --wait --timeout=7m"
          
          echo "Deployment complete!"
          echo "Pod status:"
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config get pods"
          echo "Service status:"
          ssh -i ~/.ssh/cluster-key.pem -o StrictHostKeyChecking=no \
            ec2-user@$MASTER_IP "kubectl --kubeconfig=/home/ec2-user/.kube/config get svc"

      - name: Get ALB DNS
        working-directory: ./terraform
        run: |
          ALB_DNS=$(terraform output -raw load_balancer_dns)
          echo "============================================"
          echo "APPLICATION URL: http://$ALB_DNS"
          echo "============================================"
          echo ""
          echo "Wait 2-3 minutes for ALB health checks to pass."
          echo "Then open the URL in your browser."
